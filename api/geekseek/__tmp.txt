async function callOpenAIAPI({ input, promptText, promptLines }) {
  const apiKey = process.env.OPENAI_API_KEY;
  // Compose prompts regardless, so we can return/console.log them even if no key
  const system = `You are a precise local search aggregator.
Return only strict JSON. No markdown. No prose.
Task: Produce a results array of nearby places that match the user intent.
Rules:
- Output top N items (N provided) as { "results": Place[] } only.
- Use realistic, publicly verifiable data style; never invent specific facts.
- If a field is unknown, use null, do not guess.
- Respect location and radius; prioritize distance ascending, then currently open first, then rating descending.
- rating is 0â€“5 (float), priceLevel is 0â€“4, reviewCount is integer.
- openingHours.periods: [{ day:"mon|tue|...", open:"HH:MM", close:"HH:MM" }] and set currentStatusText when possible.
- payments: include cash/cards/applePay/googlePay when known; else null.
- amenities: include wheelchairAccessible, parking{available,valet,street,lot}, wifi{available,free}, etc.
- Include address, phone, website, mapsUrl if available; else null.
- Include categories, cuisines when applicable; else [] or null.
- Include location {lat,lng} and distanceMeters (approximate allowed).
- Include a photos array if available; else [].
- Provide source {provider,url} and set confidence 0..1 for the match quality.
Do not include any commentary outside the JSON.`;

  const example = samplePlace(1);
  const user = [
    "Follow these constraints line-by-line:",
    ...promptLines,
    "Return only JSON with key `results` (Place[]) and realistic fields.",
    "Use this field list as guidance: " + JSON.stringify(Object.keys(example)),
  ].join("\n");

  if (!apiKey) {
    // Still expose what would have been sent
    return {
      provider: "stub",
      model: null,
      results: null,
      reason: "missing_openai_key",
      prompt: { system, user, lines: promptLines },
    };
  }

  // Compose a JSON-only instruction to produce place objects following our schema
  // (already built above)

  // Use OpenAI responses endpoint via fetch to avoid adding deps
  const url = "https://api.openai.com/v1/responses";
  const body = {
    model: process.env.OPENAI_MODEL || "gpt-4o-mini",
    input: [
      { role: "system", content: system },
      { role: "user", content: user },
    ],
    response_format: { type: "json_object" },
  };

  try {
    // Log the exact prompt we are about to send
    console.log("[geekseek] OpenAI request", {
      model: body.model,
      system,
      user,
      lines: promptLines,
    });
    const started = Date.now();
    const resp = await fetch(url, {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${apiKey}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body),
    });
    if (!resp.ok) {
      console.log("[geekseek] OpenAI http error", { status: resp.status });
      return { provider: "openai", model: body.model, results: null, reason: `http_${resp.status}` , prompt: { system, user, lines: promptLines } };
    }
    const data = await resp.json();
    const latencyMs = Date.now() - started;
    console.log("[geekseek] OpenAI response", { latencyMs });
    // Response content.text should be JSON per response_format
    const text = data?.output?.[0]?.content?.[0]?.text || data?.output_text || "";
    let parsed = null;
    try {
      parsed = JSON.parse(text);
    } catch (_) {
      // Some models return JSON in data.output_text directly
      if (typeof data === "object" && data && data.results) parsed = data;
    }
    const results = Array.isArray(parsed?.results) ? parsed.results : null;
    return { provider: "openai", model: body.model, results, latencyMs, prompt: { system, user, lines: promptLines } };
  } catch (e) {
    console.log("[geekseek] OpenAI network error", { message: e?.message });
    return { provider: "openai", model: body.model, results: null, reason: "network_error", prompt: { system, user, lines: promptLines } };
  }
}
